"'use strict';\n\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  ArrayPrototypePushApply,\n  ArrayPrototypeSort,\n  ArrayPrototypeUnshift,\n  BigIntPrototypeValueOf,\n  BooleanPrototypeValueOf,\n  DatePrototypeGetTime,\n  DatePrototypeToISOString,\n  DatePrototypeToString,\n  ErrorPrototypeToString,\n  FunctionPrototypeCall,\n  FunctionPrototypeToString,\n  JSONStringify,\n  MapPrototypeGetSize,\n  MapPrototypeEntries,\n  MathFloor,\n  MathMax,\n  MathMin,\n  MathRound,\n  MathSqrt,\n  Number,\n  NumberIsNaN,\n  NumberParseFloat,\n  NumberParseInt,\n  NumberPrototypeValueOf,\n  Object,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyNames,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectIs,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectPrototypePropertyIsEnumerable,\n  ObjectSeal,\n  ObjectSetPrototypeOf,\n  ReflectOwnKeys,\n  RegExp,\n  RegExpPrototypeTest,\n  RegExpPrototypeToString,\n  SafeStringIterator,\n  SafeMap,\n  SafeSet,\n  SetPrototypeGetSize,\n  SetPrototypeValues,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeCodePointAt,\n  StringPrototypeIncludes,\n  StringPrototypeNormalize,\n  StringPrototypePadEnd,\n  StringPrototypePadStart,\n  StringPrototypeRepeat,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeToLowerCase,\n  StringPrototypeTrim,\n  StringPrototypeValueOf,\n  SymbolPrototypeToString,\n  SymbolPrototypeValueOf,\n  SymbolIterator,\n  SymbolToStringTag,\n  TypedArrayPrototypeGetLength,\n  TypedArrayPrototypeGetSymbolToStringTag,\n  Uint8Array,\n  globalThis,\n  uncurryThis,\n} = primordials;\n\nconst {\n  getOwnNonIndexProperties,\n  getPromiseDetails,\n  getProxyDetails,\n  kPending,\n  kRejected,\n  previewEntries,\n  getConstructorName: internalGetConstructorName,\n  getExternalValue,\n  propertyFilter: {\n    ALL_PROPERTIES,\n    ONLY_ENUMERABLE\n  }\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol,\n  isError,\n  join,\n  removeColors\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  },\n  isStackOverflowError\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction,\n  isGeneratorFunction,\n  isAnyArrayBuffer,\n  isArrayBuffer,\n  isArgumentsObject,\n  isBoxedPrimitive,\n  isDataView,\n  isExternal,\n  isMap,\n  isMapIterator,\n  isModuleNamespaceObject,\n  isNativeError,\n  isPromise,\n  isSet,\n  isSetIterator,\n  isWeakMap,\n  isWeakSet,\n  isRegExp,\n  isDate,\n  isTypedArray,\n  isStringObject,\n  isNumberObject,\n  isBooleanObject,\n  isBigIntObject,\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  validateObject,\n} = require('internal/validators');\n\nlet hexSlice;\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis),\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/, e)\n  )\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed, `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false,\n  depth: 2,\n  colors: false,\n  customInspect: true,\n  showProxy: false,\n  maxArrayLength: 100,\n  maxStringLength: 10000,\n  breakLength: 80,\n  compact: 3,\n  sorted: false,\n  getters: false\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00', '\\\\x01', '\\\\x02', '\\\\x03', '\\\\x04', '\\\\x05', '\\\\x06', '\\\\x07', // x07\n  '\\\\b', '\\\\t', '\\\\n', '\\\\x0B', '\\\\f', '\\\\r', '\\\\x0E', '\\\\x0F',           // x0F\n  '\\\\x10', '\\\\x11', '\\\\x12', '\\\\x13', '\\\\x14', '\\\\x15', '\\\\x16', '\\\\x17', // x17\n  '\\\\x18', '\\\\x19', '\\\\x1A', '\\\\x1B', '\\\\x1C', '\\\\x1D', '\\\\x1E', '\\\\x1F', // x1F\n  '', '', '', '', '', '', '', \"\\\\'\", '', '', '', '', '', '', '', '',      // x2F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x3F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x4F\n  '', '', '', '', '', '', '', '', '', '', '', '', '\\\\\\\\', '', '', '',     // x5F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x6F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\x7F',    // x7F\n  '\\\\x80', '\\\\x81', '\\\\x82', '\\\\x83', '\\\\x84', '\\\\x85', '\\\\x86', '\\\\x87', // x87\n  '\\\\x88', '\\\\x89', '\\\\x8A', '\\\\x8B', '\\\\x8C', '\\\\x8D', '\\\\x8E', '\\\\x8F', // x8F\n  '\\\\x90', '\\\\x91', '\\\\x92', '\\\\x93', '\\\\x94', '\\\\x95', '\\\\x96', '\\\\x97', // x97\n  '\\\\x98', '\\\\x99', '\\\\x9A', '\\\\x9B', '\\\\x9C', '\\\\x9D', '\\\\x9E', '\\\\x9F', // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/master/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern, 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx, isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize,\n    showHidden: ctx.showHidden,\n    depth: ctx.depth,\n    colors: ctx.colors,\n    customInspect: ctx.customInspect,\n    showProxy: ctx.showProxy,\n    maxArrayLength: ctx.maxArrayLength,\n    maxStringLength: ctx.maxStringLength,\n    breakLength: ctx.breakLength,\n    compact: ctx.compact,\n    sorted: ctx.sorted,\n    getters: ctx.getters,\n    ...ctx.userOptions\n  };\n\n  // Typically, the target value will be an instance of `Object`. If that is\n  // *not* the case, the object may come from another vm.Context, and we want\n  // to avoid passing it objects from this Context in that case, so we remove\n  // the prototype from the returned object itself + the `stylize()` function,\n  // and remove all other non-primitives, including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret, null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value, flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value, flavour)}`;\n      } catch {}\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be, which is safe to pass along.\n      return stylized;\n    }, null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* Legacy: value, showHidden, depth, colors */\nfunction inspect(value, opts) {\n  // Default options\n  const ctx = {\n    budget: {},\n    indentationLvl: 0,\n    seen: [],\n    currentDepth: 0,\n    stylize: stylizeNoColor,\n    showHidden: inspectDefaultOptions.showHidden,\n    depth: inspectDefaultOptions.depth,\n    colors: inspectDefaultOptions.colors,\n    customInspect: inspectDefaultOptions.customInspect,\n    showProxy: inspectDefaultOptions.showProxy,\n    maxArrayLength: inspectDefaultOptions.maxArrayLength,\n    maxStringLength: inspectDefaultOptions.maxStringLength,\n    breakLength: inspectDefaultOptions.breakLength,\n    compact: inspectDefaultOptions.compact,\n    sorted: inspectDefaultOptions.sorted,\n    getters: inspectDefaultOptions.getters\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions, key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx, value, 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect, 'defaultOptions', {\n  get() {\n    return inspectDefaultOptions;\n  },\n  set(options) {\n    validateObject(options, 'options');\n    return ObjectAssign(inspectDefaultOptions, options);\n  }\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null), {\n  reset: [0, 0],\n  bold: [1, 22],\n  dim: [2, 22], // Alias: faint\n  italic: [3, 23],\n  underline: [4, 24],\n  blink: [5, 25],\n  // Swap forground and background colors\n  inverse: [7, 27], // Alias: swapcolors, swapColors\n  hidden: [8, 28], // Alias: conceal\n  strikethrough: [9, 29], // Alias: strikeThrough, crossedout, crossedOut\n  doubleunderline: [21, 24], // Alias: doubleUnderline\n  black: [30, defaultFG],\n  red: [31, defaultFG],\n  green: [32, defaultFG],\n  yellow: [33, defaultFG],\n  blue: [34, defaultFG],\n  magenta: [35, defaultFG],\n  cyan: [36, defaultFG],\n  white: [37, defaultFG],\n  bgBlack: [40, defaultBG],\n  bgRed: [41, defaultBG],\n  bgGreen: [42, defaultBG],\n  bgYellow: [43, defaultBG],\n  bgBlue: [44, defaultBG],\n  bgMagenta: [45, defaultBG],\n  bgCyan: [46, defaultBG],\n  bgWhite: [47, defaultBG],\n  framed: [51, 54],\n  overlined: [53, 55],\n  gray: [90, defaultFG], // Alias: grey, blackBright\n  redBright: [91, defaultFG],\n  greenBright: [92, defaultFG],\n  yellowBright: [93, defaultFG],\n  blueBright: [94, defaultFG],\n  magentaBright: [95, defaultFG],\n  cyanBright: [96, defaultFG],\n  whiteBright: [97, defaultFG],\n  bgGray: [100, defaultBG], // Alias: bgGrey, bgBlackBright\n  bgRedBright: [101, defaultBG],\n  bgGreenBright: [102, defaultBG],\n  bgYellowBright: [103, defaultBG],\n  bgBlueBright: [104, defaultBG],\n  bgMagentaBright: [105, defaultBG],\n  bgCyanBright: [106, defaultBG],\n  bgWhiteBright: [107, defaultBG],\n});\n\nfunction defineColorAlias(target, alias) {\n  ObjectDefineProperty(inspect.colors, alias, {\n    get() {\n      return this[target];\n    },\n    set(value) {\n      this[target] = value;\n    },\n    configurable: true,\n    enumerable: false\n  });\n}\n\ndefineColorAlias('gray', 'grey');\ndefineColorAlias('gray', 'blackBright');\ndefineColorAlias('bgGray', 'bgGrey');\ndefineColorAlias('bgGray', 'bgBlackBright');\ndefineColorAlias('dim', 'faint');\ndefineColorAlias('strikethrough', 'crossedout');\ndefineColorAlias('strikethrough', 'strikeThrough');\ndefineColorAlias('strikethrough', 'crossedOut');\ndefineColorAlias('hidden', 'conceal');\ndefineColorAlias('inverse', 'swapColors');\ndefineColorAlias('inverse', 'swapcolors');\ndefineColorAlias('doubleunderline', 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null), {\n  special: 'cyan',\n  number: 'yellow',\n  bigint: 'yellow',\n  boolean: 'yellow',\n  undefined: 'grey',\n  null: 'bold',\n  string: 'green',\n  symbol: 'green',\n  date: 'magenta',\n  // \"name\": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red',\n  module: 'underline'\n});\n\nfunction addQuotes(str, quotes) {\n  if (quotes === -1) {\n    return `\"${str}\"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nconst escapeFn = (str) => meta[StringPrototypeCharCodeAt(str)];\n\n// Escape control characters, single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present, do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist, check for\n  // backticks. If they do not exist, use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str, \"'\")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str, '\"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str, '`') &&\n               !StringPrototypeIncludes(str, '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest, str))\n    return addQuotes(str, singleQuote);\n  if (str.length > 100) {\n    str = StringPrototypeReplace(str, escapeReplace, escapeFn);\n    return addQuotes(str, singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  const lastIndex = str.length;\n  for (let i = 0; i < lastIndex; i++) {\n    const point = StringPrototypeCharCodeAt(str, i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str, last, i)}${meta[point]}`;\n      }\n      last = i + 1;\n    }\n  }\n\n  if (last !== lastIndex) {\n    result += StringPrototypeSlice(str, last);\n  }\n  return addQuotes(result, singleQuote);\n}\n\nfunction stylizeWithColor(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object, proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj, ctx, recurseTimes, protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp, descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx, tmp, firstProto || tmp, recurseTimes, protoProps);\n      }\n      return descriptor.value.name;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto, ctx, recurseTimes + 1, protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto, {\n      ...ctx,\n      customInspect: false,\n      depth: -1\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx, main, obj, recurseTimes, output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys, (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main, key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj, key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx, obj, recurseTimes, key, kObjectType, desc, main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output, `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output, value);\n      }\n    }\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here, because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor, tag, fallback, size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value, showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys, symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module, but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value, key);\n      ArrayPrototypePushApply(keys, ArrayPrototypeFilter(symbols, filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value, constructor, tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor, tag, fallback);\n}\n\nfunction formatProxy(ctx, proxy, recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]', 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx, proxy[0], recurseTimes),\n    formatValue(ctx, proxy[1], recurseTimes),\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx, res, '', ['Proxy [', ']'], kArrayExtrasType, recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx, value, recurseTimes, typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize, value, ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value, !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (ctx.showProxy) {\n      return formatProxy(ctx, proxy, recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module, its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom, context, depth, getUserOptions(ctx, isCrossContext));\n      // If the custom inspection method returned `this`, don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx, ret, recurseTimes);\n        }\n        return ret.replace(/\\n/g, `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value, index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value, index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`, 'special');\n  }\n\n  return formatRaw(ctx, value, recurseTimes, typedArray);\n}\n\nfunction formatRaw(ctx, value, recurseTimes, typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value, SymbolToStringTag\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (value[SymbolIterator] || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor, tag, 'Array', `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value, filter);\n      braces = [`${prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor, tag, 'Set', `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ?\n        formatSet.bind(null, value) :\n        formatSet.bind(null, SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor, tag, 'Map', `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ?\n        formatMap.bind(null, value) :\n        formatMap.bind(null, MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value, filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor, tag, fallback, `(${size})`);\n      braces = [`${prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = formatTypedArray.bind(null, bound, size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Map', tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null, braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Set', tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null, braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value, ctx.showHidden);\n    braces = ['{', '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value, constructor, tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base, 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\n      );\n      const prefix = getPrefix(constructor, tag, 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base, 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor, tag, 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base, 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value, constructor, tag, ctx, keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor, tag, arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys, 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;\n      // .buffer goes last, it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys, 'byteLength', 'byteOffset', 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null, keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value, ctx, keys, constructor, tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`, 'special');\n        }\n        return `${getCtxStyle(value, constructor, tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value, constructor, tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName, 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx, value, recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(\n        formatProperty(ctx, value, recurseTimes, keys[i], extrasType));\n    }\n    if (protoProps !== undefined) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`, 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length, keys.length, ...sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx, output, base, braces, extrasType, recurseTimes, value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit, limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type, tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`, '}'];\n}\n\nfunction getBoxedBase(value, ctx, keys, constructor, tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings, we have to remove the 0-n indexed entries,\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0, value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor, fn(value), ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base, StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value, constructor, tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value, 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value, constructor, tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.slice(0, 5) === 'class' && stringified.endsWith('}')) {\n    const slice = stringified.slice(5, -1);\n    const bracketIndex = slice.indexOf('{');\n    if (bracketIndex !== -1 &&\n        (!slice.slice(0, bracketIndex).includes('(') ||\n          // Slow path to guarantee that it's indeed a class.\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value, constructor, tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction formatError(err, constructor, tag, ctx, keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let len = name.length;\n  let stack = err.stack ? String(err.stack) : ErrorPrototypeToString(err);\n\n  // Do not \"duplicate\" error properties that are already included in the output\n  // otherwise.\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name', 'message', 'stack']) {\n      const index = keys.indexOf(name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && stack.includes(err[name])) {\n        keys.splice(index, 1);\n      }\n    }\n  }\n\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for \"regular errors\" (errors that \"look normal\") for now.\n  if (constructor === null ||\n      (name.endsWith('Error') &&\n      stack.startsWith(name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = stack.indexOf('\\n    at', pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else if (ctx.colors) {\n    // Highlight userland code and node modules.\n    let newStack = stack.slice(0, stackStart);\n    const lines = stack.slice(stackStart + 1).split('\\n');\n    for (const line of lines) {\n      const core = line.match(coreModuleRegExp);\n      if (core !== null && NativeModule.exists(core[1])) {\n        newStack += `\\n${ctx.stylize(line, 'undefined')}`;\n      } else {\n        // This adds underscores to all node_modules to quickly identify them.\n        let nodeModule;\n        newStack += '\\n';\n        let pos = 0;\n        while (nodeModule = nodeModulesRegExp.exec(line)) {\n          // '/node_modules/'.length === 14\n          newStack += line.slice(pos, nodeModule.index + 14);\n          newStack += ctx.stylize(nodeModule[1], 'module');\n          pos = nodeModule.index + nodeModule[0].length;\n        }\n        newStack += pos === 0 ? line : line.slice(pos);\n      }\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g, `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx, output, value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the \"... n more items\" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first,\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i], ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e., if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias, 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\n        ) / biasedMax\n      ),\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax),\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4,\n      // Limit the columns to a maximum of fifteen.\n      15\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns, outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}, `, padding, ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j], padding, ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp, str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp, output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]',\n      'special'\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction formatNumber(fn, value) {\n  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n  return fn(ObjectIs(value, -0) ? '-0' : `${value}`, 'number');\n}\n\nfunction formatBigInt(fn, value) {\n  return fn(`${value}n`, 'bigint');\n}\n\nfunction formatPrimitive(fn, value, ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0, ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n        // function.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value\n        .split(/(?<=\\n)/)\n        .map((line) => fn(strEscape(line), 'string'))\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value), 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn, value);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn, value);\n  if (typeof value === 'boolean')\n    return fn(`${value}`, 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined', 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value), 'symbol');\n}\n\nfunction formatNamespaceObject(keys, ctx, value, recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx, value, recurseTimes, keys[i],\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned, even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);\n      const pos = output[i].lastIndexOf(' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = output[i].slice(0, pos + 1) +\n                  ctx.stylize('<uninitialized>', 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx, value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)', 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    hexSlice(buffer, 0, MathMin(ctx.maxArrayLength, buffer.length)),\n    /(.{2})/g, '$1 '));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx, value, recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0, ctx.maxArrayLength), valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value, i)) {\n      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  return output;\n}\n\nfunction formatTypedArray(value, length, ctx, ignored, recurseTimes) {\n  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i)\n    output[i] = elementFormatter(ctx.stylize, value[i]);\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last, it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT',\n      'length',\n      'byteLength',\n      'byteOffset',\n      'buffer',\n    ]) {\n      const str = formatValue(ctx, value[key], recurseTimes, true);\n      ArrayPrototypePush(output, `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value, ctx, ignored, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output, formatValue(ctx, v, recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value, ctx, ignored, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k, 1: v } of value) {\n    output.push(\n      `${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`\n    );\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  const maxLength = MathMin(maxArrayLength, entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx, entries[i], recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output,\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  // Entries exist as [key1, val1, key2, val2, ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength, len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx, entries[pos], recurseTimes),\n        formatValue(ctx, entries[pos + 1], recurseTimes),\n      ];\n      output[i] = reduceToSingleString(\n        ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>', 'special')];\n}\n\nfunction formatWeakSet(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);\n}\n\nfunction formatWeakMap(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);\n}\n\nfunction formatIterator(braces, ctx, value, recurseTimes) {\n  const { 0: entries, 1: isKeyValue } = previewEntries(value, true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');\n    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n  }\n\n  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n}\n\nfunction formatPromise(ctx, value, recurseTimes) {\n  let output;\n  const { 0: state, 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>', 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx, result, recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>', 'special')} ${str}` :\n        str,\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, key, type, desc,\n                        original = value) {\n  let name, str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value, key) ||\n    { value: value[key], enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx, desc.value, recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get, original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s, tmp, ctx);\n          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`, sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]', 'special');\n  } else {\n    str = ctx.stylize('undefined', 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = StringPrototypeReplace(\n      SymbolPrototypeToString(key),\n      strEscapeSequencesReplacer, escapeFn\n    );\n    name = `[${ctx.stylize(tmp, 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = \"['__proto__']\";\n  } else if (desc.enumerable === false) {\n    const tmp = StringPrototypeReplace(key,\n                                       strEscapeSequencesReplacer, escapeFn);\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeTest(keyStrRegExp, key)) {\n    name = ctx.stylize(key, 'name');\n  } else {\n    name = ctx.stylize(strEscape(key), 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx, output, start, base) {\n  // Each entry is separated by at least a comma. Thus, we start with a total\n  // length of at least `output.length`. In addition, some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base, '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx, output, base, braces, extrasType, recurseTimes, value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped,\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx, output, value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`, as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx, output, start, base)) {\n          return `${base ? `${base} ` : ''}${braces[0]} ${join(output, ', ')}` +\n            ` ${braces[1]}`;\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' ', ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx, output, 0, base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output, ', ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' ', ctx.indentationLvl);\n  // If the opening \"brace\" is too large, like in the case of \"Set {\",\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output, `,\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value, getFullProxy);\n  if (proxyTarget !== undefined) {\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value, 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer, 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer, 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) =>\n  StringPrototypeSplit(error.message, '\\n', 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSONStringify(a);\n      } catch (err) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(err);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined, args);\n}\n\nfunction formatWithOptions(inspectOptions, ...args) {\n  if (typeof inspectOptions !== 'object' || inspectOptions === null) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'inspectOptions', 'object', inspectOptions);\n  }\n  return formatWithOptionsInternal(inspectOptions, args);\n}\n\nfunction formatWithOptionsInternal(inspectOptions, args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first, i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first, ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumber(stylizeNoColor, tempArg);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = `${tempArg}n`;\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg, {\n                  ...inspectOptions,\n                  compact: 3,\n                  colors: false,\n                  depth: 0\n                });\n              }\n              break;\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = `${tempNum}n`;\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor, Number(tempNum));\n              }\n              break;\n            case 79: // 'O'\n              tempStr = inspect(args[++a], inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a], {\n                ...inspectOptions,\n                showHidden: true,\n                showProxy: true,\n                depth: 4\n              });\n              break;\n            case 105: // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = `${tempInteger}n`;\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor,\n                                       NumberParseInt(tempInteger));\n              }\n              break;\n            case 102: // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor,\n                                       NumberParseFloat(tempFloat));\n              }\n              break;\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first, lastPos, i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first, lastPos, i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first, lastPos, i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first, lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string, ambiguousAsFullWidth, expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment, since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str, removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII, we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str, removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str, 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char, 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 0x1F || // C0 control codes\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n      // Combining Diacritical Marks for Symbols\n      (code >= 0x20D0 && code <= 0x20FF) ||\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n  };\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  return str.replace(ansi, '');\n}\n\nmodule.exports = {\n  inspect,\n  format,\n  formatWithOptions,\n  getStringWidth,\n  inspectDefaultOptions,\n  stripVTControlCharacters\n};\n"
