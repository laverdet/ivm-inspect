"/* eslint node-core/documented-errors: \"error\" */\n/* eslint node-core/alphabetize-errors: \"error\" */\n/* eslint node-core/prefer-util-format-errors: \"error\" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\n\nconst {\n  AggregateError,\n  ArrayFrom,\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  Error,\n  ErrorCaptureStackTrace,\n  ErrorPrototypeToString,\n  JSONStringify,\n  MapPrototypeGet,\n  MathAbs,\n  MathMax,\n  Number,\n  NumberIsInteger,\n  ObjectDefineProperty,\n  ObjectIsExtensible,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  RangeError,\n  ReflectApply,\n  RegExpPrototypeTest,\n  SafeArrayIterator,\n  SafeMap,\n  SafeWeakMap,\n  String,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeMatch,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolFor,\n  SyntaxError,\n  TypeError,\n  URIError,\n} = primordials;\n\nconst isWindows = process.platform === 'win32';\n\nconst messages = new SafeMap();\nconst codes = {};\n\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol',\n];\n\nconst MainContextError = Error;\nconst overrideStackTrace = new SafeWeakMap();\nconst kNoOverride = Symbol('kNoOverride');\nlet userStackTraceLimit;\nconst nodeInternalPrefix = '__node_internal_';\nconst prepareStackTrace = (globalThis, error, trace) => {\n  // API for node internals to override error stack formatting\n  // without interfering with userland code.\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error, trace);\n  }\n\n  const firstFrame = trace[0]?.getFunctionName();\n  if (firstFrame && StringPrototypeStartsWith(firstFrame, nodeInternalPrefix)) {\n    for (let l = trace.length - 1; l >= 0; l--) {\n      const fn = trace[l]?.getFunctionName();\n      if (fn && StringPrototypeStartsWith(fn, nodeInternalPrefix)) {\n        ArrayPrototypeSplice(trace, 0, l + 1);\n        break;\n      }\n    }\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`,\n    // it is updated at every new exception in `captureLargerStackTrace`.\n    if (trace.length > userStackTraceLimit)\n      ArrayPrototypeSplice(trace, userStackTraceLimit);\n  }\n\n  const globalOverride =\n    maybeOverridePrepareStackTrace(globalThis, error, trace);\n  if (globalOverride !== kNoOverride) return globalOverride;\n\n  // Normal error formatting:\n  //\n  // Error: Message\n  //     at function (file)\n  //     at file\n  const errorString = ErrorPrototypeToString(error);\n  if (trace.length === 0) {\n    return errorString;\n  }\n  return `${errorString}\\n    at ${ArrayPrototypeJoin(trace, '\\n    at ')}`;\n};\n\nconst maybeOverridePrepareStackTrace = (globalThis, error, trace) => {\n  // Polyfill of V8's Error.prepareStackTrace API.\n  // https://crbug.com/v8/7848\n  // `globalThis` is the global that contains the constructor which\n  // created `error`.\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\n    return globalThis.Error.prepareStackTrace(error, trace);\n  }\n  // We still have legacy usage that depends on the main context's `Error`\n  // being used, even when the error is from a different context.\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\n  if (typeof MainContextError.prepareStackTrace === 'function') {\n    return MainContextError.prepareStackTrace(error, trace);\n  }\n\n  return kNoOverride;\n};\n\nconst aggregateTwoErrors = hideStackFrames((innerError, outerError) => {\n  if (innerError && outerError) {\n    if (ArrayIsArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      ArrayPrototypePush(outerError.errors, innerError);\n      return outerError;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new AggregateError(new SafeArrayIterator([\n      outerError,\n      innerError,\n    ]), outerError.message);\n    err.code = outerError.code;\n    return err;\n  }\n  return innerError || outerError;\n});\n\n// Lazily loaded\nlet util;\nlet assert;\n\nlet internalUtil = null;\nfunction lazyInternalUtil() {\n  if (!internalUtil) {\n    internalUtil = require('internal/util');\n  }\n  return internalUtil;\n}\n\nlet internalUtilInspect = null;\nfunction lazyInternalUtilInspect() {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect;\n}\n\nlet buffer;\nfunction lazyBuffer() {\n  if (buffer === undefined)\n    buffer = require('buffer').Buffer;\n  return buffer;\n}\n\nconst addCodeToName = hideStackFrames(function addCodeToName(err, name, code) {\n  // Set the stack\n  err = captureLargerStackTrace(err);\n  // Add the error code to the name to include it in the stack trace.\n  err.name = `${name} [${code}]`;\n  // Access the stack to generate the error message including the error code\n  // from the name.\n  err.stack; // eslint-disable-line no-unused-expressions\n  // Reset the name to the actual name.\n  if (name === 'SystemError') {\n    ObjectDefineProperty(err, 'name', {\n      value: name,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  } else {\n    delete err.name;\n  }\n});\n\nfunction isErrorStackTraceLimitWritable() {\n  const desc = ObjectGetOwnPropertyDescriptor(Error, 'stackTraceLimit');\n  if (desc === undefined) {\n    return ObjectIsExtensible(Error);\n  }\n\n  return ObjectPrototypeHasOwnProperty(desc, 'writable') ?\n    desc.writable :\n    desc.set !== undefined;\n}\n\n// A specialized Error that includes an additional info property with\n// additional information about the error condition.\n// It has the properties present in a UVException but with a custom error\n// message followed by the uv error code and uv error message.\n// It also has its own error code with the original uv error context put into\n// `err.info`.\n// The context passed into this error must have .code, .syscall and .message,\n// and may have .path and .dest.\nclass SystemError extends Error {\n  constructor(key, context) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    super();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const prefix = getMessage(key, [], this);\n    let message = `${prefix}: ${context.syscall} returned ` +\n                  `${context.code} (${context.message})`;\n\n    if (context.path !== undefined)\n      message += ` ${context.path}`;\n    if (context.dest !== undefined)\n      message += ` => ${context.dest}`;\n\n    ObjectDefineProperty(this, 'message', {\n      value: message,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    addCodeToName(this, 'SystemError', key);\n\n    this.code = key;\n\n    ObjectDefineProperty(this, 'info', {\n      value: context,\n      enumerable: true,\n      configurable: true,\n      writable: false\n    });\n\n    ObjectDefineProperty(this, 'errno', {\n      get() {\n        return context.errno;\n      },\n      set: (value) => {\n        context.errno = value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    ObjectDefineProperty(this, 'syscall', {\n      get() {\n        return context.syscall;\n      },\n      set: (value) => {\n        context.syscall = value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    if (context.path !== undefined) {\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\n      // introduced. The `path` and `dest` properties in the context seem to\n      // always be of type string. We should probably just remove the\n      // `.toString()` and `Buffer.from()` operations and set the value on the\n      // context as the user did.\n      ObjectDefineProperty(this, 'path', {\n        get() {\n          return context.path != null ?\n            context.path.toString() : context.path;\n        },\n        set: (value) => {\n          context.path = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    if (context.dest !== undefined) {\n      ObjectDefineProperty(this, 'dest', {\n        get() {\n          return context.dest != null ?\n            context.dest.toString() : context.dest;\n        },\n        set: (value) => {\n          context.dest = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes, ctx) {\n    return lazyInternalUtilInspect().inspect(this, {\n      ...ctx,\n      getters: true,\n      customInspect: false\n    });\n  }\n}\n\nfunction makeSystemErrorWithCode(key) {\n  return class NodeError extends SystemError {\n    constructor(ctx) {\n      super(key, ctx);\n    }\n  };\n}\n\nfunction makeNodeErrorWithCode(Base, key) {\n  return function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    const error = new Base();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const message = getMessage(key, args, error);\n    ObjectDefineProperty(error, 'message', {\n      value: message,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    });\n    ObjectDefineProperty(error, 'toString', {\n      value() {\n        return `${this.name} [${key}]: ${this.message}`;\n      },\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    });\n    addCodeToName(error, Base.name, key);\n    error.code = key;\n    return error;\n  };\n}\n\n/**\n * This function removes unnecessary frames from Node.js core errors.\n * @template {(...args: any[]) => any} T\n * @type {(fn: T) => T}\n */\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name;\n  ObjectDefineProperty(fn, 'name', { value: hidden });\n  return fn;\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym, val, def, ...otherClasses) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym, val);\n  if (def === SystemError) {\n    def = makeSystemErrorWithCode(sym);\n  } else {\n    def = makeNodeErrorWithCode(def, sym);\n  }\n\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach((clazz) => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);\n    });\n  }\n  codes[sym] = def;\n}\n\nfunction getMessage(key, args, self) {\n  const msg = messages.get(key);\n\n  if (assert === undefined) assert = require('internal/assert');\n\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length, // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n        `match the required ones (${msg.length}).`\n    );\n    return ReflectApply(msg, self, args);\n  }\n\n  const expectedLength =\n    (StringPrototypeMatch(msg, /%[dfijoOs]/g) || []).length;\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  );\n  if (args.length === 0)\n    return msg;\n\n  ArrayPrototypeUnshift(args, msg);\n  return ReflectApply(lazyInternalUtilInspect().format, null, args);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  if (!uvBinding) {\n    uvBinding = internalBinding('uv');\n  }\n  return uvBinding;\n}\n\nconst uvUnmappedError = ['UNKNOWN', 'unknown error'];\n\nfunction uvErrmapGet(name) {\n  uvBinding = lazyUv();\n  if (!uvBinding.errmap) {\n    uvBinding.errmap = uvBinding.getErrorMap();\n  }\n  return MapPrototypeGet(uvBinding.errmap, name);\n}\n\nconst captureLargerStackTrace = hideStackFrames(\n  function captureLargerStackTrace(err) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = Infinity;\n    }\n    ErrorCaptureStackTrace(err);\n    // Reset the limit\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\n\n    return err;\n  });\n\n/**\n * This creates an error compatible with errors produced in the C++\n * function UVException using a context object with data assembled in C++.\n * The goal is to migrate them to ERR_* errors later when compatibility is\n * not a concern.\n *\n * @param {Object} ctx\n * @returns {Error}\n */\nconst uvException = hideStackFrames(function uvException(ctx) {\n  const { 0: code, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\n  let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;\n\n  let path;\n  let dest;\n  if (ctx.path) {\n    path = ctx.path.toString();\n    message += ` '${path}'`;\n  }\n  if (ctx.dest) {\n    dest = ctx.dest.toString();\n    message += ` -> '${dest}'`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // Pass the message to the constructor instead of setting it on the object\n  // to make sure it is the same as the one created in C++\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n\n  for (const prop of ObjectKeys(ctx)) {\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\n      continue;\n    }\n    err[prop] = ctx[prop];\n  }\n\n  err.code = code;\n  if (path) {\n    err.path = path;\n  }\n  if (dest) {\n    err.dest = dest;\n  }\n\n  return captureLargerStackTrace(err);\n});\n\n/**\n * This creates an error compatible with errors produced in the C++\n * This function should replace the deprecated\n * `exceptionWithHostPort()` function.\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @returns {Error}\n */\nconst uvExceptionWithHostPort = hideStackFrames(\n  function uvExceptionWithHostPort(err, syscall, address, port) {\n    const { 0: code, 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\n    const message = `${syscall} ${code}: ${uvmsg}`;\n    let details = '';\n\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${message}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.code = code;\n    ex.errno = err;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * This used to be util._errnoException().\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} [original]\n * @returns {Error}\n */\nconst errnoException = hideStackFrames(\n  function errnoException(err, syscall, original) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    const message = original ?\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\n\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(message);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * Deprecated, new function is `uvExceptionWithHostPort()`\n * New function added the error description directly\n * from C++. this method for backwards compatibility\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @param {string} [additional]\n * @returns {Error}\n */\nconst exceptionWithHostPort = hideStackFrames(\n  function exceptionWithHostPort(err, syscall, address, port, additional) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    let details = '';\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n    if (additional) {\n      details += ` - Local (${additional})`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${syscall} ${code}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * @param {number|string} code - A libuv error number or a c-ares error code\n * @param {string} syscall\n * @param {string} [hostname]\n * @returns {Error}\n */\nconst dnsException = hideStackFrames(function(code, syscall, hostname) {\n  let errno;\n  // If `code` is of type number, it is a libuv error number, else it is a\n  // c-ares error code.\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\n  // make them available in a property that's not error.errno (since they\n  // can be in conflict with libuv error codes). Also make sure\n  // util.getSystemErrorName() can understand them when an being informed that\n  // the number is a c-ares error code.\n  if (typeof code === 'number') {\n    errno = code;\n    // ENOTFOUND is not a proper POSIX error, but this error has been in place\n    // long enough that it's not practical to remove it.\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\n      code = 'ENOTFOUND'; // Fabricated error name.\n    } else {\n      code = lazyInternalUtil().getSystemErrorName(code);\n    }\n  }\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n  ex.errno = errno;\n  ex.code = code;\n  ex.syscall = syscall;\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n\n  return captureLargerStackTrace(ex);\n});\n\nfunction connResetException(msg) {\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(msg);\n  ex.code = 'ECONNRESET';\n  return ex;\n}\n\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\n/**\n * Returns true if `err.name` and `err.message` are equal to engine-specific\n * values indicating max call stack size has been exceeded.\n * \"Maximum call stack size exceeded\" in V8.\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === undefined) {\n    try {\n      function overflowStack() { overflowStack(); }\n      overflowStack();\n    } catch (err) {\n      maxStack_ErrorMessage = err.message;\n      maxStack_ErrorName = err.name;\n    }\n  }\n\n  return err && err.name === maxStack_ErrorName &&\n         err.message === maxStack_ErrorMessage;\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${StringPrototypeSlice(val, i - 3, i)}${res}`;\n  }\n  return `${StringPrototypeSlice(val, 0, i)}${res}`;\n}\n\n// Used to enhance the stack that will be picked up by the inspector\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\n\n// These are supposed to be called only on fatal exceptions before\n// the process exits.\nconst fatalExceptionStackEnhancers = {\n  beforeInspector(error) {\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\n      return error.stack;\n    }\n\n    try {\n      // Set the error.stack here so it gets picked up by the\n      // inspector.\n      error.stack = error[kEnhanceStackBeforeInspector]();\n    } catch {\n      // We are just enhancing the error. If it fails, ignore it.\n    }\n    return error.stack;\n  },\n  afterInspector(error) {\n    const originalStack = error.stack;\n    let useColors = true;\n    // Some consoles do not convert ANSI escape sequences to colors,\n    // rather display them directly to the stdout. On those consoles,\n    // libuv emulates colors by intercepting stdout stream and calling\n    // corresponding Windows API functions for setting console colors.\n    // However, fatal error are handled differently and we cannot easily\n    // highlight them. On Windows, detecting whether a console supports\n    // ANSI escape sequences is not reliable.\n    if (process.platform === 'win32') {\n      const info = internalBinding('os').getOSInformation();\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2], '.'),\n                                    Number);\n      if (ver[0] !== 10 || ver[2] < 14393) {\n        useColors = false;\n      }\n    }\n    const {\n      inspect,\n      inspectDefaultOptions: {\n        colors: defaultColors\n      }\n    } = lazyInternalUtilInspect();\n    const colors = useColors &&\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\n                   require('internal/tty').hasColors()) ||\n                   defaultColors);\n    try {\n      return inspect(error, {\n        colors,\n        customInspect: false,\n        depth: MathMax(inspect.defaultOptions.depth, 5)\n      });\n    } catch {\n      return originalStack;\n    }\n  }\n};\n\n// Node uses an AbortError that isn't exactly the same as the DOMException\n// to make usage of the error in userland and readable-stream easier.\n// It is a regular error with `.code` and `.name`.\nclass AbortError extends Error {\n  constructor() {\n    super('The operation was aborted');\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n}\nmodule.exports = {\n  addCodeToName, // Exported for NghttpError\n  aggregateTwoErrors,\n  codes,\n  dnsException,\n  errnoException,\n  exceptionWithHostPort,\n  getMessage,\n  hideStackFrames,\n  isErrorStackTraceLimitWritable,\n  isStackOverflowError,\n  connResetException,\n  uvErrmapGet,\n  uvException,\n  uvExceptionWithHostPort,\n  SystemError,\n  AbortError,\n  // This is exported only to facilitate testing.\n  E,\n  kNoOverride,\n  prepareStackTrace,\n  maybeOverridePrepareStackTrace,\n  overrideStackTrace,\n  kEnhanceStackBeforeInspector,\n  fatalExceptionStackEnhancers\n};\n\n// To declare an error message, use the E(sym, val, def) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The def must be an error class.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1', 'This is the error value', Error);\n// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`, RangeError);\n//\n// Once an error code has been assigned, the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\n//\n// Note: Node.js specific errors must begin with the prefix ERR_\nE('ERR_AMBIGUOUS_ARGUMENT', 'The \"%s\" argument is ambiguous. %s', TypeError);\nE('ERR_ARG_NOT_ITERABLE', '%s must be iterable', TypeError);\nE('ERR_ASSERTION', '%s', Error);\nE('ERR_ASYNC_CALLBACK', '%s must be a function', TypeError);\nE('ERR_ASYNC_TYPE', 'Invalid name for async \"type\": %s', TypeError);\nE('ERR_BROTLI_INVALID_PARAM', '%s is not a valid Brotli parameter', RangeError);\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name = undefined) => {\n    if (name) {\n      return `\"${name}\" is outside of buffer bounds`;\n    }\n    return 'Attempt to access memory outside buffer bounds';\n  }, RangeError);\nE('ERR_BUFFER_TOO_LARGE',\n  'Cannot create a Buffer larger than %s bytes',\n  RangeError);\nE('ERR_CANNOT_WATCH_SIGINT', 'Cannot watch for SIGINT signals', Error);\nE('ERR_CHILD_CLOSED_BEFORE_REPLY',\n  'Child closed before reply received', Error);\nE('ERR_CHILD_PROCESS_IPC_REQUIRED',\n  \"Forked processes must have an IPC channel, missing value 'ipc' in %s\",\n  Error);\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER', '%s maxBuffer length exceeded',\n  RangeError);\nE('ERR_CONSOLE_WRITABLE_STREAM',\n  'Console expects a writable stream instance for %s', TypeError);\nE('ERR_CONTEXT_NOT_INITIALIZED', 'context used is not initialized', Error);\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED',\n  'Custom engines not supported by this OpenSSL', Error);\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT', 'Invalid ECDH format: %s', TypeError);\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY',\n  'Public key is not valid for specified curve', Error);\nE('ERR_CRYPTO_ENGINE_UNKNOWN', 'Engine \"%s\" was not found', Error);\nE('ERR_CRYPTO_FIPS_FORCED',\n  'Cannot set FIPS mode, it was forced with --force-fips at startup.', Error);\nE('ERR_CRYPTO_FIPS_UNAVAILABLE', 'Cannot set FIPS mode in a non-FIPS build.',\n  Error);\nE('ERR_CRYPTO_HASH_FINALIZED', 'Digest already called', Error);\nE('ERR_CRYPTO_HASH_UPDATE_FAILED', 'Hash update failed', Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY', 'Incompatible %s: %s', Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS', 'The selected key encoding %s %s.',\n  Error);\nE('ERR_CRYPTO_INVALID_DIGEST', 'Invalid digest: %s', TypeError);\nE('ERR_CRYPTO_INVALID_JWK', 'Invalid JWK data', TypeError);\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE',\n  'Invalid key object type %s, expected %s.', TypeError);\nE('ERR_CRYPTO_INVALID_STATE', 'Invalid state for operation %s', Error);\nE('ERR_CRYPTO_JWK_UNSUPPORTED_CURVE', 'Unsupported JWK EC curve: %s.', Error);\nE('ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE', 'Unsupported JWK Key Type.', Error);\nE('ERR_CRYPTO_PBKDF2_ERROR', 'PBKDF2 error', Error);\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER', 'Invalid scrypt parameter', Error);\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED', 'Scrypt algorithm not supported', Error);\n// Switch to TypeError. The current implementation does not seem right.\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED', 'No key provided to sign', Error);\nE('ERR_DIR_CLOSED', 'Directory handle was closed', Error);\nE('ERR_DIR_CONCURRENT_OPERATION',\n  'Cannot do synchronous work on directory handle with concurrent ' +\n  'asynchronous operations', Error);\nE('ERR_DNS_SET_SERVERS_FAILED', 'c-ares failed to set servers: \"%s\" [%s]',\n  Error);\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE',\n  'A callback was registered through ' +\n     'process.setUncaughtExceptionCaptureCallback(), which is mutually ' +\n     'exclusive with using the `domain` module',\n  Error);\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE',\n  'The `domain` module is in use, which is mutually exclusive with calling ' +\n     'process.setUncaughtExceptionCaptureCallback()',\n  Error);\nE('ERR_ENCODING_INVALID_ENCODED_DATA', function(encoding, ret) {\n  this.errno = ret;\n  return `The encoded data was not valid for encoding ${encoding}`;\n}, TypeError);\nE('ERR_ENCODING_NOT_SUPPORTED', 'The \"%s\" encoding is not supported',\n  RangeError);\nE('ERR_EVAL_ESM_CANNOT_PRINT', '--print cannot be used with ESM input', Error);\nE('ERR_EVENT_RECURSION', 'The event \"%s\" is already being dispatched', Error);\nE('ERR_FALSY_VALUE_REJECTION', function(reason) {\n  this.reason = reason;\n  return 'Promise was rejected with falsy value';\n}, Error);\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM',\n  'The feature %s is unavailable on the current platform' +\n  ', which is being used to run Node.js',\n  TypeError);\nE('ERR_FS_EISDIR', 'Path is a directory', SystemError);\nE('ERR_FS_FILE_TOO_LARGE', 'File size (%s) is greater than 2 GB', RangeError);\nE('ERR_FS_INVALID_SYMLINK_TYPE',\n  'Symlink type must be one of \"dir\", \"file\", or \"junction\". Received \"%s\"',\n  Error); // Switch to TypeError. The current implementation does not seem right\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN',\n  'HTTP/2 ALTSVC frames require a valid origin', TypeError);\nE('ERR_HTTP2_ALTSVC_LENGTH',\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes', TypeError);\nE('ERR_HTTP2_CONNECT_AUTHORITY',\n  ':authority header is required for CONNECT requests', Error);\nE('ERR_HTTP2_CONNECT_PATH',\n  'The :path header is forbidden for CONNECT requests', Error);\nE('ERR_HTTP2_CONNECT_SCHEME',\n  'The :scheme header is forbidden for CONNECT requests', Error);\nE('ERR_HTTP2_GOAWAY_SESSION',\n  'New streams cannot be created after receiving a GOAWAY', Error);\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND',\n  'Cannot specify additional headers after response initiated', Error);\nE('ERR_HTTP2_HEADERS_SENT', 'Response has already been initiated.', Error);\nE('ERR_HTTP2_HEADER_SINGLE_VALUE',\n  'Header field \"%s\" must only have a single value', TypeError);\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED',\n  'Informational status codes cannot be used', RangeError);\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS',\n  'HTTP/1 Connection specific headers are forbidden: \"%s\"', TypeError);\nE('ERR_HTTP2_INVALID_HEADER_VALUE',\n  'Invalid value \"%s\" for header \"%s\"', TypeError);\nE('ERR_HTTP2_INVALID_INFO_STATUS',\n  'Invalid informational status code: %s', RangeError);\nE('ERR_HTTP2_INVALID_ORIGIN',\n  'HTTP/2 ORIGIN frames require a valid origin', TypeError);\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH',\n  'Packed settings length must be a multiple of six', RangeError);\nE('ERR_HTTP2_INVALID_PSEUDOHEADER',\n  '\"%s\" is an invalid pseudoheader or is used incorrectly', TypeError);\nE('ERR_HTTP2_INVALID_SESSION', 'The session has been destroyed', Error);\nE('ERR_HTTP2_INVALID_SETTING_VALUE',\n  // Using default arguments here is important so the arguments are not counted\n  // towards `Function#length`.\n  function(name, actual, min = undefined, max = undefined) {\n    this.actual = actual;\n    if (min !== undefined) {\n      this.min = min;\n      this.max = max;\n    }\n    return `Invalid value for setting \"${name}\": ${actual}`;\n  }, TypeError, RangeError);\nE('ERR_HTTP2_INVALID_STREAM', 'The stream has been destroyed', Error);\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK',\n  'Maximum number of pending settings acknowledgements', Error);\nE('ERR_HTTP2_NESTED_PUSH',\n  'A push stream cannot initiate another push stream.', Error);\nE('ERR_HTTP2_NO_MEM', 'Out of memory', Error);\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION',\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)',\n  Error);\nE('ERR_HTTP2_ORIGIN_LENGTH',\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes', TypeError);\nE('ERR_HTTP2_OUT_OF_STREAMS',\n  'No stream ID is available because maximum stream ID has been reached',\n  Error);\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN',\n  'Responses with %s status must not have a payload', Error);\nE('ERR_HTTP2_PING_CANCEL', 'HTTP2 ping cancelled', Error);\nE('ERR_HTTP2_PING_LENGTH', 'HTTP2 ping payload must be 8 bytes', RangeError);\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED',\n  'Cannot set HTTP/2 pseudo-headers', TypeError);\nE('ERR_HTTP2_PUSH_DISABLED', 'HTTP/2 client has disabled push streams', Error);\nE('ERR_HTTP2_SEND_FILE', 'Directories cannot be sent', Error);\nE('ERR_HTTP2_SEND_FILE_NOSEEK',\n  'Offset or length can only be specified for regular files', Error);\nE('ERR_HTTP2_SESSION_ERROR', 'Session closed with error code %s', Error);\nE('ERR_HTTP2_SETTINGS_CANCEL', 'HTTP2 session settings canceled', Error);\nE('ERR_HTTP2_SOCKET_BOUND',\n  'The socket is already bound to an Http2Session', Error);\nE('ERR_HTTP2_SOCKET_UNBOUND',\n  'The socket has been disconnected from the Http2Session', Error);\nE('ERR_HTTP2_STATUS_101',\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2', Error);\nE('ERR_HTTP2_STATUS_INVALID', 'Invalid status code: %s', RangeError);\nE('ERR_HTTP2_STREAM_CANCEL', function(error) {\n  let msg = 'The pending stream has been canceled';\n  if (error) {\n    this.cause = error;\n    if (typeof error.message === 'string')\n      msg += ` (caused by: ${error.message})`;\n  }\n  return msg;\n}, Error);\nE('ERR_HTTP2_STREAM_ERROR', 'Stream closed with error code %s', Error);\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY',\n  'A stream cannot depend on itself', Error);\nE('ERR_HTTP2_TOO_MANY_INVALID_FRAMES', 'Too many invalid HTTP/2 frames', Error);\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT',\n  'Trailing headers have already been sent', Error);\nE('ERR_HTTP2_TRAILERS_NOT_READY',\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\n  'emitted', Error);\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL', 'protocol \"%s\" is unsupported.', Error);\nE('ERR_HTTP_HEADERS_SENT',\n  'Cannot %s headers after they are sent to the client', Error);\nE('ERR_HTTP_INVALID_HEADER_VALUE',\n  'Invalid value \"%s\" for header \"%s\"', TypeError);\nE('ERR_HTTP_INVALID_STATUS_CODE', 'Invalid status code: %s', RangeError);\nE('ERR_HTTP_REQUEST_TIMEOUT', 'Request timeout', Error);\nE('ERR_HTTP_SOCKET_ENCODING',\n  'Changing the socket encoding is not allowed per RFC7230 Section 3.', Error);\nE('ERR_HTTP_TRAILER_INVALID',\n  'Trailers are invalid with this transfer encoding', Error);\nE('ERR_INCOMPATIBLE_OPTION_PAIR',\n  'Option \"%s\" cannot be used in combination with option \"%s\"', TypeError);\nE('ERR_INPUT_TYPE_NOT_ALLOWED', '--input-type can only be used with string ' +\n  'input via --eval, --print, or STDIN', Error);\nE('ERR_INSPECTOR_ALREADY_ACTIVATED',\n  'Inspector is already activated. Close it with inspector.close() ' +\n  'before activating it again.',\n  Error);\nE('ERR_INSPECTOR_ALREADY_CONNECTED', '%s is already connected', Error);\nE('ERR_INSPECTOR_CLOSED', 'Session was closed', Error);\nE('ERR_INSPECTOR_COMMAND', 'Inspector error %d: %s', Error);\nE('ERR_INSPECTOR_NOT_ACTIVE', 'Inspector is not active', Error);\nE('ERR_INSPECTOR_NOT_AVAILABLE', 'Inspector is not available', Error);\nE('ERR_INSPECTOR_NOT_CONNECTED', 'Session is not connected', Error);\nE('ERR_INSPECTOR_NOT_WORKER', 'Current thread is not a worker', Error);\nE('ERR_INTERNAL_ASSERTION', (message) => {\n  const suffix = 'This is caused by either a bug in Node.js ' +\n    'or incorrect usage of Node.js internals.\\n' +\n    'Please open an issue with this stack trace at ' +\n    'https://github.com/nodejs/node/issues\\n';\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\n}, Error);\nE('ERR_INVALID_ADDRESS_FAMILY', function(addressType, host, port) {\n  this.host = host;\n  this.port = port;\n  return `Invalid address family: ${addressType} ${host}:${port}`;\n}, RangeError);\nE('ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\");\n    if (!ArrayIsArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (StringPrototypeEndsWith(name, ' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = StringPrototypeIncludes(name, '.') ? 'property' : 'argument';\n      msg += `\"${name}\" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string',\n             'All expected entries have to be of type string');\n      if (ArrayPrototypeIncludes(kTypes, value)) {\n        ArrayPrototypePush(types, StringPrototypeToLowerCase(value));\n      } else if (RegExpPrototypeTest(classRegExp, value)) {\n        ArrayPrototypePush(instances, value);\n      } else {\n        assert(value !== 'object',\n               'The value \"object\" should be written as \"Object\"');\n        ArrayPrototypePush(other, value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = ArrayPrototypeIndexOf(types, 'object');\n      if (pos !== -1) {\n        ArrayPrototypeSplice(types, pos, 1);\n        ArrayPrototypePush(instances, 'Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = ArrayPrototypePop(types);\n        msg += `one of type ${ArrayPrototypeJoin(types, ', ')}, or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = ArrayPrototypePop(instances);\n        msg +=\n          `an instance of ${ArrayPrototypeJoin(instances, ', ')}, or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = ArrayPrototypePop(other);\n        msg += `one of ${ArrayPrototypeJoin(other, ', ')}, or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    if (actual == null) {\n      msg += `. Received ${actual}`;\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === 'object') {\n      if (actual.constructor && actual.constructor.name) {\n        msg += `. Received an instance of ${actual.constructor.name}`;\n      } else {\n        const inspected = lazyInternalUtilInspect()\n          .inspect(actual, { depth: -1 });\n        msg += `. Received ${inspected}`;\n      }\n    } else {\n      let inspected = lazyInternalUtilInspect()\n        .inspect(actual, { colors: false });\n      if (inspected.length > 25)\n        inspected = `${StringPrototypeSlice(inspected, 0, 25)}...`;\n      msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n  }, TypeError);\nE('ERR_INVALID_ARG_VALUE', (name, value, reason = 'is invalid') => {\n  let inspected = lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) {\n    inspected = `${StringPrototypeSlice(inspected, 0, 128)}...`;\n  }\n  const type = StringPrototypeIncludes(name, '.') ? 'property' : 'argument';\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}, TypeError, RangeError);\nE('ERR_INVALID_ASYNC_ID', 'Invalid %s value: %s', RangeError);\nE('ERR_INVALID_BUFFER_SIZE',\n  'Buffer size must be a multiple of %s', RangeError);\nE('ERR_INVALID_CALLBACK',\n  'Callback must be a function. Received %O', TypeError);\nE('ERR_INVALID_CHAR',\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name, field = undefined) => {\n    let msg = `Invalid character in ${name}`;\n    if (field !== undefined) {\n      msg += ` [\"${field}\"]`;\n    }\n    return msg;\n  }, TypeError);\nE('ERR_INVALID_CURSOR_POS',\n  'Cannot set cursor row without setting its column', TypeError);\nE('ERR_INVALID_FD',\n  '\"fd\" must be a positive integer: %s', RangeError);\nE('ERR_INVALID_FD_TYPE', 'Unsupported fd type: %s', TypeError);\nE('ERR_INVALID_FILE_URL_HOST',\n  'File URL host must be \"localhost\" or empty on %s', TypeError);\nE('ERR_INVALID_FILE_URL_PATH', 'File URL path %s', TypeError);\nE('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent', TypeError);\nE('ERR_INVALID_HTTP_TOKEN', '%s must be a valid HTTP token [\"%s\"]', TypeError);\nE('ERR_INVALID_IP_ADDRESS', 'Invalid IP address: %s', TypeError);\nE('ERR_INVALID_MODULE_SPECIFIER', (request, reason, base = undefined) => {\n  return `Invalid module \"${request}\" ${reason}${base ?\n    ` imported from ${base}` : ''}`;\n}, TypeError);\nE('ERR_INVALID_PACKAGE_CONFIG', (path, base, message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\n    ''}${message ? `. ${message}` : ''}`;\n}, Error);\nE('ERR_INVALID_PACKAGE_TARGET',\n  (pkgPath, key, target, isImport = false, base = undefined) => {\n    const relError = typeof target === 'string' && !isImport &&\n      target.length && !StringPrototypeStartsWith(target, './');\n    if (key === '.') {\n      assert(isImport === false);\n      return `Invalid \"exports\" main target ${JSONStringify(target)} defined ` +\n        `in the package config ${pkgPath}package.json${base ?\n          ` imported from ${base}` : ''}${relError ?\n          '; targets must start with \"./\"' : ''}`;\n    }\n    return `Invalid \"${isImport ? 'imports' : 'exports'}\" target ${\n      JSONStringify(target)} defined for '${key}' in the package config ${\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\n      '; targets must start with \"./\"' : ''}`;\n  }, Error);\nE('ERR_INVALID_PERFORMANCE_MARK',\n  'The \"%s\" performance mark has not been set', Error);\nE('ERR_INVALID_PROTOCOL',\n  'Protocol \"%s\" not supported. Expected \"%s\"',\n  TypeError);\nE('ERR_INVALID_REPL_EVAL_CONFIG',\n  'Cannot specify both \"breakEvalOnSigint\" and \"eval\" for REPL', TypeError);\nE('ERR_INVALID_REPL_INPUT', '%s', TypeError);\nE('ERR_INVALID_RETURN_PROPERTY', (input, name, prop, value) => {\n  return `Expected a valid ${input} to be returned for the \"${prop}\" from the` +\n         ` \"${name}\" function but got ${value}.`;\n}, TypeError);\nE('ERR_INVALID_RETURN_PROPERTY_VALUE', (input, name, prop, value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned for the \"${prop}\" from the` +\n         ` \"${name}\" function but got ${type}.`;\n}, TypeError);\nE('ERR_INVALID_RETURN_VALUE', (input, name, value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned from the \"${name}\"` +\n         ` function but got ${type}.`;\n}, TypeError);\nE('ERR_INVALID_STATE', 'Invalid state: %s', Error);\nE('ERR_INVALID_SYNC_FORK_INPUT',\n  'Asynchronous forks do not support ' +\n    'Buffer, TypedArray, DataView or string input: %s',\n  TypeError);\nE('ERR_INVALID_THIS', 'Value of \"this\" must be of type %s', TypeError);\nE('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple', TypeError);\nE('ERR_INVALID_URI', 'URI malformed', URIError);\nE('ERR_INVALID_URL', function(input) {\n  this.input = input;\n  return `Invalid URL: ${input}`;\n}, TypeError);\nE('ERR_INVALID_URL_SCHEME',\n  (expected) => {\n    if (typeof expected === 'string')\n      expected = [expected];\n    assert(expected.length <= 2);\n    const res = expected.length === 2 ?\n      `one of scheme ${expected[0]} or ${expected[1]}` :\n      `of scheme ${expected[0]}`;\n    return `The URL must be ${res}`;\n  }, TypeError);\nE('ERR_IPC_CHANNEL_CLOSED', 'Channel closed', Error);\nE('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected', Error);\nE('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe', Error);\nE('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks', Error);\nE('ERR_MANIFEST_ASSERT_INTEGRITY',\n  (moduleURL, realIntegrities) => {\n    let msg = `The content of \"${\n      moduleURL\n    }\" does not match the expected integrity.`;\n    if (realIntegrities.size) {\n      const sri = ArrayPrototypeJoin(\n        ArrayFrom(realIntegrities.entries(),\n                  ({ 0: alg, 1: dgs }) => `${alg}-${dgs}`),\n        ' '\n      );\n      msg += ` Integrities found are: ${sri}`;\n    } else {\n      msg += ' The resource was not found in the policy.';\n    }\n    return msg;\n  }, Error);\nE('ERR_MANIFEST_DEPENDENCY_MISSING',\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\n  'conditions: %s',\n  Error);\nE('ERR_MANIFEST_INTEGRITY_MISMATCH',\n  'Manifest resource %s has multiple entries but integrity lists do not match',\n  SyntaxError);\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD',\n  'Manifest resource %s has invalid property value for %s',\n  TypeError);\nE('ERR_MANIFEST_TDZ', 'Manifest initialization has not yet run', Error);\nE('ERR_MANIFEST_UNKNOWN_ONERROR',\n  'Manifest specified unknown error behavior \"%s\".',\n  SyntaxError);\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);\nE('ERR_MISSING_ARGS',\n  (...args) => {\n    assert(args.length > 0, 'At least one arg needs to be specified');\n    let msg = 'The ';\n    const len = args.length;\n    const wrap = (a) => `\"${a}\"`;\n    args = ArrayPrototypeMap(\n      args,\n      (a) => (ArrayIsArray(a) ?\n        ArrayPrototypeJoin(ArrayPrototypeMap(a, wrap), ' or ') :\n        wrap(a))\n    );\n    switch (len) {\n      case 1:\n        msg += `${args[0]} argument`;\n        break;\n      case 2:\n        msg += `${args[0]} and ${args[1]} arguments`;\n        break;\n      default:\n        msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args, 0, len - 1), ', ');\n        msg += `, and ${args[len - 1]} arguments`;\n        break;\n    }\n    return `${msg} must be specified`;\n  }, TypeError);\nE('ERR_MISSING_OPTION', '%s is required', TypeError);\nE('ERR_MODULE_NOT_FOUND', (path, base, type = 'package') => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}, Error);\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);\nE('ERR_NAPI_CONS_FUNCTION', 'Constructor must be a function', TypeError);\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS',\n  'byte_offset + byte_length should be less than or equal to the size in ' +\n    'bytes of the array passed in',\n  RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT',\n  'start offset of %s should be a multiple of %s', RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH',\n  'Invalid typed array length', RangeError);\nE('ERR_NO_CRYPTO',\n  'Node.js is not compiled with OpenSSL crypto support', Error);\nE('ERR_NO_ICU',\n  '%s is not supported on Node.js compiled without ICU', TypeError);\nE('ERR_OPERATION_FAILED', 'Operation failed: %s', Error);\nE('ERR_OUT_OF_RANGE',\n  (str, range, input, replaceDefaultBoolean = false) => {\n    assert(range, 'Missing \"range\" argument');\n    let msg = replaceDefaultBoolean ? str :\n      `The value of \"${str}\" is out of range.`;\n    let received;\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received);\n      }\n      received += 'n';\n    } else {\n      received = lazyInternalUtilInspect().inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }, RangeError);\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED', (specifier, packagePath, base) => {\n  return `Package import specifier \"${specifier}\" is not defined${packagePath ?\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\n}, TypeError);\nE('ERR_PACKAGE_PATH_NOT_EXPORTED', (pkgPath, subpath, base = undefined) => {\n  if (subpath === '.')\n    return `No \"exports\" main defined in ${pkgPath}package.json${base ?\n      ` imported from ${base}` : ''}`;\n  return `Package subpath '${subpath}' is not defined by \"exports\" in ${\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n}, Error);\nE('ERR_PERFORMANCE_INVALID_TIMESTAMP',\n  '%d is not a valid timestamp', TypeError);\nE('ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS', '%s', TypeError);\nE('ERR_REQUIRE_ESM',\n  (filename, parentPath = null, packageJsonPath = null) => {\n    let msg = `Must use import to load ES Module: ${filename}`;\n    if (parentPath && packageJsonPath) {\n      const path = require('path');\n      const basename = path.basename(filename) === path.basename(parentPath) ?\n        filename : path.basename(filename);\n      msg +=\n        '\\nrequire() of ES modules is not supported.\\nrequire() of ' +\n        `${filename} from ${parentPath} ` +\n        'is an ES module file as it is a .js file whose nearest parent ' +\n        'package.json contains \"type\": \"module\" which defines all .js ' +\n        'files in that package scope as ES modules.\\nInstead rename ' +\n        `${basename} to end in .cjs, change the requiring code to use ` +\n        'import(), or remove \"type\": \"module\" from ' +\n        `${packageJsonPath}.\\n`;\n      return msg;\n    }\n    return msg;\n  }, Error);\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED',\n  'Script execution was interrupted by `SIGINT`', Error);\nE('ERR_SERVER_ALREADY_LISTEN',\n  'Listen method has been called more than once without closing.', Error);\nE('ERR_SERVER_NOT_RUNNING', 'Server is not running.', Error);\nE('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound', Error);\nE('ERR_SOCKET_BAD_BUFFER_SIZE',\n  'Buffer size must be a positive integer', TypeError);\nE('ERR_SOCKET_BAD_PORT', (name, port, allowZero = true) => {\n  assert(typeof allowZero === 'boolean',\n         \"The 'allowZero' argument must be of type boolean.\");\n  const operator = allowZero ? '>=' : '>';\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\n}, RangeError);\nE('ERR_SOCKET_BAD_TYPE',\n  'Bad socket type specified. Valid types are: udp4, udp6', TypeError);\nE('ERR_SOCKET_BUFFER_SIZE',\n  'Could not get or set buffer size',\n  SystemError);\nE('ERR_SOCKET_CLOSED', 'Socket is closed', Error);\nE('ERR_SOCKET_DGRAM_IS_CONNECTED', 'Already connected', Error);\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED', 'Not connected', Error);\nE('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running', Error);\nE('ERR_SRI_PARSE',\n  'Subresource Integrity string %j had an unexpected %j at position %d',\n  SyntaxError);\nE('ERR_STREAM_ALREADY_FINISHED',\n  'Cannot call %s after a stream was finished',\n  Error);\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT',\n  'stream.unshift() after end event', Error);\nE('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode', Error);\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);\nE('ERR_SYNTHETIC', 'JavaScript Callstack', Error);\nE('ERR_SYSTEM_ERROR', 'A system error occurred', SystemError);\nE('ERR_TLS_CERT_ALTNAME_INVALID', function(reason, host, cert) {\n  this.reason = reason;\n  this.host = host;\n  this.cert = cert;\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\n}, Error);\nE('ERR_TLS_DH_PARAM_SIZE', 'DH parameter size %s is less than 2048', Error);\nE('ERR_TLS_HANDSHAKE_TIMEOUT', 'TLS handshake timeout', Error);\nE('ERR_TLS_INVALID_CONTEXT', '%s must be a SecureContext', TypeError);\nE('ERR_TLS_INVALID_PROTOCOL_VERSION',\n  '%j is not a valid %s TLS protocol version', TypeError);\nE('ERR_TLS_INVALID_STATE', 'TLS socket connection must be securely established',\n  Error);\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT',\n  'TLS protocol version %j conflicts with secureProtocol %j', TypeError);\nE('ERR_TLS_RENEGOTIATION_DISABLED',\n  'TLS session renegotiation disabled for this socket', Error);\n\n// This should probably be a `TypeError`.\nE('ERR_TLS_REQUIRED_SERVER_NAME',\n  '\"servername\" is required parameter for Server.addContext', Error);\nE('ERR_TLS_SESSION_ATTACK', 'TLS session renegotiation attack detected', Error);\nE('ERR_TLS_SNI_FROM_SERVER',\n  'Cannot issue SNI from a TLS server-side socket', Error);\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED',\n  'At least one category is required', TypeError);\nE('ERR_TRACE_EVENTS_UNAVAILABLE', 'Trace events are unavailable', Error);\n\n// This should probably be a `RangeError`.\nE('ERR_TTY_INIT_FAILED', 'TTY initialization failed', SystemError);\nE('ERR_UNAVAILABLE_DURING_EXIT', 'Cannot call function in process exit ' +\n  'handler', Error);\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET',\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\n    'callback was already active',\n  Error);\nE('ERR_UNESCAPED_CHARACTERS', '%s contains unescaped characters', TypeError);\nE('ERR_UNHANDLED_ERROR',\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (err = undefined) => {\n    const msg = 'Unhandled error.';\n    if (err === undefined) return msg;\n    return `${msg} (${err})`;\n  }, Error);\nE('ERR_UNKNOWN_BUILTIN_MODULE', 'No such built-in module: %s', Error);\nE('ERR_UNKNOWN_CREDENTIAL', '%s identifier does not exist: %s', Error);\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);\nE('ERR_UNKNOWN_FILE_EXTENSION',\n  'Unknown file extension \"%s\" for %s',\n  TypeError);\nE('ERR_UNKNOWN_MODULE_FORMAT', 'Unknown module format: %s', RangeError);\nE('ERR_UNKNOWN_SIGNAL', 'Unknown signal: %s', TypeError);\nE('ERR_UNSUPPORTED_DIR_IMPORT', \"Directory import '%s' is not supported \" +\n'resolving ES modules imported from %s', Error);\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME', (url) => {\n  let msg = 'Only file and data URLs are supported by the default ESM loader';\n  if (isWindows && url.protocol.length === 2) {\n    msg +=\n      '. On Windows, absolute paths must be valid file:// URLs';\n  }\n  msg += `. Received protocol '${url.protocol}'`;\n  return msg;\n}, Error);\n\n// This should probably be a `TypeError`.\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE',\n  'At least one valid performance entry type is required', Error);\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING',\n  'A dynamic import callback was not specified.', TypeError);\nE('ERR_VM_MODULE_ALREADY_LINKED', 'Module has already been linked', Error);\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA',\n  'Cached data cannot be created for a module which has been evaluated', Error);\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT',\n  'Linked modules must use the same context', Error);\nE('ERR_VM_MODULE_LINKING_ERRORED',\n  'Linking has already failed for the provided module', Error);\nE('ERR_VM_MODULE_NOT_MODULE',\n  'Provided module is not an instance of Module', Error);\nE('ERR_VM_MODULE_STATUS', 'Module status %s', Error);\nE('ERR_WASI_ALREADY_STARTED', 'WASI instance has already started', Error);\nE('ERR_WORKER_INIT_FAILED', 'Worker initialization failure: %s', Error);\nE('ERR_WORKER_INVALID_EXEC_ARGV', (errors, msg = 'invalid execArgv flags') =>\n  `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors, ', ')}`,\n  Error);\nE('ERR_WORKER_NOT_RUNNING', 'Worker instance not running', Error);\nE('ERR_WORKER_OUT_OF_MEMORY',\n  'Worker terminated due to reaching memory limit: %s', Error);\nE('ERR_WORKER_PATH', (filename) =>\n  'The worker script or module filename must be an absolute path or a ' +\n  'relative path starting with \\'./\\' or \\'../\\'.' +\n  (StringPrototypeStartsWith(filename, 'file://') ?\n    ' Wrap file:// URLs with `new URL`.' : ''\n  ) +\n  (StringPrototypeStartsWith(filename, 'data:text/javascript') ?\n    ' Wrap data: URLs with `new URL`.' : ''\n  ) +\n  ` Received \"${filename}\"`,\n  TypeError);\nE('ERR_WORKER_UNSERIALIZABLE_ERROR',\n  'Serializing an uncaught exception failed', Error);\nE('ERR_WORKER_UNSUPPORTED_EXTENSION',\n  'The worker script extension must be \".js\", \".mjs\", or \".cjs\". Received \"%s\"',\n  TypeError);\nE('ERR_WORKER_UNSUPPORTED_OPERATION',\n  '%s is not supported in workers', TypeError);\nE('ERR_ZLIB_INITIALIZATION_FAILED', 'Initialization failed', Error);\n"
